export default class h{constructor(t=0,s=0){this.x=t,this.y=s}static fromVector(t){return new h(t.x,t.y)}static fromArray(t){return new h(t[0],t[1])}set(t,s=t){return this.x=t,this.y=s,this}setToPolar(t,s=1){return this.x=Math.cos(t)*s,this.y=Math.sin(t)*s,this}equals(t){return this.x===t.x&&this.y===t.y}angle(){let t=Math.atan2(this.y,this.x);return t<0&&(t+=2*Math.PI),t}setAngle(t){return this.setToPolar(t,this.length())}add(t){return this.x+=t.x,this.y+=t.y,this}subtract(t){return this.x-=t.x,this.y-=t.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}divide(t){return this.x/=t.x,this.y/=t.y,this}scale(t){return isFinite(t)?(this.x*=t,this.y*=t):(this.x=0,this.y=0),this}negate(){return this.x=-this.x,this.y=-this.y,this}distance(t){const s=t.x-this.x,i=t.y-this.y;return Math.sqrt(s*s+i*i)}distanceSq(t){const s=t.x-this.x,i=t.y-this.y;return s*s+i*i}length(){const t=this.x,s=this.y;return Math.sqrt(t*t+s*s)}setLength(t){return this.normalize().scale(t)}lengthSq(){const t=this.x,s=this.y;return t*t+s*s}normalize(){const t=this.x,s=this.y;let i=t*t+s*s;return i>0&&(i=1/Math.sqrt(i),this.x=t*i,this.y=s*i),this}normalizeRightHand(){const t=this.x;return this.x=this.y*-1,this.y=t,this}normalizeLeftHand(){const t=this.x;return this.x=this.y,this.y=t*-1,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lerp(t,s=0){const i=this.x,e=this.y;return this.x=i+s*(t.x-i),this.y=e+s*(t.y-e),this}reset(){return this.x=0,this.y=0,this}limit(t){const s=this.length();return s&&s>t&&this.scale(t/s),this}reflect(t){return t=h.fromVector(t).normalize(),this.subtract(t.scale(2*this.dot(t)))}mirror(t){return this.reflect(t).negate()}rotate(t){const s=Math.cos(t),i=Math.sin(t);return this.set(s*this.x-i*this.y,i*this.x+s*this.y)}toPolar(){return{p:Math.sqrt(this.x*this.x+this.y*this.y),q:Math.atan2(this.y,this.x)}}}
