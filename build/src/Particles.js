import c from"./Renderer.js";import{ParticleManager as _}from"./Particle.js";import o from"./Vector2.js";import d from"./Rectangle.js";import p from"./Line.js";import h from"./QuadTree.js";import"./Circle.js";export default class u{constructor(e,i){this._canvas=e,this.ctx=this._canvas.getContext("2d"),this._particleManager=null,this._renderer=null,this._boundUpdate=this.update.bind(this),this._isRunning=!1,this._linkedParticles,this._distanceToLink,this._ticks=0,this._deltas=new Array(200),this._debug=!1,this._viewport=new d,this._boundary,this._quadtree,this._resizeTimeout,this.processSettings(i),this._resize&&window.addEventListener("resize",this.onResize.bind(this)),this.start(),console.log("Particles started!")}onResize(e){this._resizeTimeout&&clearTimeout(this._resizeTimeout),this._resizeTimeout=setTimeout(()=>this.setSize(window.innerWidth,window.innerHeight),100)}start(){this._isRunning=!0,window.requestAnimationFrame(this._boundUpdate)}stop(){this._isRunning=!1}update(){const e=Date.now();this._quadtree=new h(this._boundary,4);const i=this._particleManager.particles.filter(t=>t.active);for(const t of i)t.position.x+=t.velocity.x,t.position.y+=t.velocity.y,this.checkBoundary(t,this._boundary),this._quadtree.insert(t);let r;this._linkedParticles&&(r=this.linkPartiles(this._particleManager.particles,this._distanceToLink)),this._renderer.particles=this._particleManager.particles,this._renderer.lines=r,this._renderer.deltas=this._deltas,this._renderer.render(),this._isRunning&&window.requestAnimationFrame(this._boundUpdate),this._ticks++;const s=Date.now()-e;this._deltas.push(s),this._deltas.length>this._deltas.length-1&&this._deltas.shift();const a=this._deltas.filter(t=>t!==void 0)}linkPartiles(e,i){const r=[];for(let n=0;n<e.length-1;n++)for(let s=n+1;s<e.length;s++){const a=e[n].position.distance(e[s].position);if(a<i){const t=new p(o.fromVector(e[n].position),o.fromVector(e[s].position)),l=1-a/i;t.alpha=l,r.push(t)}}return r}setSize(e,i){this._canvas.width=e,this._canvas.height=i,this._renderer.viewportSize=new o(e,i),this._viewport.set(0,0,e,i),this._boundary=new d(-this._distanceToLink,-this._distanceToLink,e+this._distanceToLink*2,i+this._distanceToLink*2),this._quadtree=new h(this._boundary,4)}get debug(){return this._debug}set debug(e){this._debug=e,this._renderer._debug=e}processSettings(e){if(this._resize=e.resize,this._linkedParticles=e.particles.linkedParticles,this._distanceToLink=e.particles.distanceToLink,this._particleManager=new _(e.particles.amount),this._particleManager.generateParticlesRandomly(e.renderer.width,e.renderer.height,this._distanceToLink,e.particles.maxVelocity,e.particles.maxVelocity,e.particles.maxRadius),e.staticParticles)for(const i of e.staticParticles){const r=this._particleManager.createParticle();r.active=!1,r.radius=0,r.position.set(e.renderer.width*i[0],e.renderer.height*i[1])}if(this._renderer=new c(this.ctx,e.renderer.backgroundColor),this.setSize(e.renderer.width,e.renderer.height),e.renderer.linearGradient){const i=this.ctx.createLinearGradient(e.renderer.width*e.renderer.linearGradient.x1,e.renderer.height*e.renderer.linearGradient.y1,e.renderer.width*e.renderer.linearGradient.x2,e.renderer.height*e.renderer.linearGradient.y2);i.addColorStop(0,e.renderer.linearGradient.color1),i.addColorStop(1,e.renderer.linearGradient.color2),this._renderer.gradient=i}this.debug=e.debug}checkBoundary(e,i){e.position.x<i.left&&(e.position.x=i.right),e.position.x>i.right&&(e.position.x=i.left),e.position.y<i.top&&(e.position.y=i.bottom),e.position.y>i.bottom&&(e.position.y=i.top)}}
